<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Personal Finance Dashboard</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Font Awesome (for icons, replacing SVG) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Chart.js DataLabels Plugin -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>

    <!-- Chosen Palette: Warm Neutrals with Financial Accents -->
    <!-- Application Structure Plan:
        1.  **Global Header:** Contains the App Title and the Global Month Filter. This ensures context is maintained across all views.
        2.  **Navigation Bar:** Tab-based navigation (Assets, P&L, Cash Flow) to switch contexts easily without page reloads.
        3.  **Main Content Area:** - **Asset Dashboard:** Focuses on long-term health (Net Worth Trend) and current snapshot (Allocation).
            - **P&L Dashboard:** Focuses on operational efficiency (Fixed vs Variable costs).
            - **Cash Flow Dashboard:** Focuses on liquidity (In vs Out).
        4.  **Data Layer:** "Mock" database objects (monthlyBalances, transactions) simulate the Google Sheets schema structure to power visualizations.
    -->
    <!-- Visualization & Content Choices:
        1.  **Trend Graph (Assets):** Line Chart. Goal: Show growth over time. Interaction: Hover for exact numbers.
        2.  **Portfolio Distribution:** Doughnut Chart. Goal: Show diversity. Interaction: Click legend to filter.
        3.  **Income vs Expense:** Stacked Bar Chart. Goal: Compare Fixed/Variable costs monthly.
        4.  **Cash Flow:** Combo Chart (Bar for volume, Line for Net Flow). Goal: Highlight deficits/surpluses.
        5.  **Confirming NO SVG/Mermaid:** All icons are FontAwesome font-based. Charts are HTML5 Canvas via Chart.js.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f5f5f4; /* Stone 100 - Warm Neutral */
            color: #44403c; /* Stone 700 */
        }
        
        /* Chart Container Styling for Responsiveness */
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 100%;
            margin-left: auto;
            margin-right: auto;
            height: 300px; /* Default mobile height */
        }
        
        @media (min-width: 768px) {
            .chart-container {
                height: 350px; /* Tablet/Desktop height */
            }
        }

        .tab-btn {
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
        }
        .tab-btn.active {
            color: #0d9488; /* Teal 600 */
            border-bottom-color: #0d9488;
            font-weight: 600;
        }
        
        .card {
            background-color: white;
            border-radius: 0.75rem; /* rounded-xl */
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
            border: 1px solid #e7e5e4; /* Stone 200 */
        }

        /* Metric badge styling */
        .badge-positive {
            background-color: #d1fae5;
            color: #065f46;
        }
        .badge-negative {
            background-color: #fee2e2;
            color: #991b1b;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <!-- Navbar / Header -->
    <header class="bg-white border-b border-stone-200 sticky top-0 z-50">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex justify-between items-center h-16">
                <!-- Logo / Title -->
                <div class="flex items-center">
                    <i class="fa-solid fa-wallet text-teal-600 text-2xl mr-3"></i>
                    <h1 class="text-xl font-bold text-stone-800 tracking-tight">FinDash</h1>
                </div>

                <!-- Global Controls -->
                <div class="flex items-center space-x-4">
                    <!-- Pension Toggle -->
                    <label class="inline-flex items-center cursor-pointer mr-2">
                        <input type="checkbox" id="pensionToggle" class="sr-only peer">
                        <div class="relative w-11 h-6 bg-stone-200 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-teal-600"></div>
                        <span class="ms-2 text-sm font-medium text-stone-600">연금 포함</span>
                    </label>

                    <!-- Month Selector -->
                    <div class="relative">
                        <select id="monthSelector" class="appearance-none bg-white border border-stone-200 text-stone-700 py-2 pl-4 pr-10 rounded-lg shadow-sm focus:outline-none focus:ring-2 focus:ring-teal-500 focus:border-transparent font-medium">
                            <!-- Populated by JS -->
                        </select>
                        <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-stone-500">
                            <i class="fa-solid fa-chevron-down text-xs"></i>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Sub-Navigation (Tabs) -->
    <div class="bg-white border-b border-stone-200 shadow-sm">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <nav class="-mb-px flex space-x-8" aria-label="Tabs">
                <button class="tab-btn active py-4 px-1 text-sm font-medium flex items-center" data-tab="assets">
                    <i class="fa-solid fa-chart-line mr-2"></i> 자산 및 순자산
                </button>
                <button class="tab-btn py-4 px-1 text-sm font-medium flex items-center" data-tab="pnl">
                    <i class="fa-solid fa-file-invoice-dollar mr-2"></i> 수입 및 지출
                </button>
                <button class="tab-btn py-4 px-1 text-sm font-medium flex items-center" data-tab="cashflow">
                    <i class="fa-solid fa-money-bill-transfer mr-2"></i> 현금 흐름
                </button>
            </nav>
        </div>
    </div>

    <!-- Main Content -->
    <main class="flex-grow max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8 w-full">
        
        <!-- Tab 1: Assets Dashboard -->
        <section id="tab-assets" class="space-y-6">
            <!-- Description Banner -->
            <div class="bg-teal-50 border-l-4 border-teal-500 p-4 rounded-r shadow-sm">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <i class="fa-solid fa-chart-pie text-teal-500"></i>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-teal-700">
                            <strong>자산 분석 :</strong> 현재시점 기준 포트폴리오를 분석하여 최적의 투자 방향성을 고민한다.
                        </p>
                    </div>
                </div>
            </div>


            <!-- Top Cards: KPI Summary -->
            <!-- Top Cards: KPI Summary -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-6">
                <!-- 순자산 (Net Worth) -->
                <div class="card p-6 border-l-4 border-teal-500 cursor-pointer hover:shadow-lg transition-all" onclick="openBreakdownModal('NetWorth')">
                    <h3 class="text-sm font-medium text-stone-500 uppercase tracking-wider">순자산 (Net Worth)</h3>
                    <p class="mt-2 text-3xl font-bold text-stone-800" id="kpi-net-worth">0원</p>
                    <div class="mt-2 flex items-center text-sm">
                        <span class="text-teal-600 font-medium"><i class="fa-solid fa-calculator mr-1"></i>총자산 - 총부채</span>
                    </div>
                </div>
                <!-- 총자산 (Assets) -->
                <div class="card p-6 border-l-4 border-emerald-400 cursor-pointer hover:shadow-lg transition-all" onclick="openBreakdownModal('Asset')">
                    <h3 class="text-sm font-medium text-stone-500 uppercase tracking-wider">총자산 (Total Assets)</h3>
                    <p class="mt-2 text-3xl font-bold text-stone-800" id="kpi-total-assets">0원</p>
                    <div class="mt-2 flex items-center text-sm">
                        <span class="text-emerald-600 font-medium"><i class="fa-solid fa-arrow-trend-up mr-1"></i>유동 및 고정 자산</span>
                    </div>
                </div>
                <!-- 총부채 (Liabilities) -->
                <div class="card p-6 border-l-4 border-rose-400 cursor-pointer hover:shadow-lg transition-all" onclick="openBreakdownModal('Liability')">
                    <h3 class="text-sm font-medium text-stone-500 uppercase tracking-wider">총부채 (Total Liabilities)</h3>
                    <p class="mt-2 text-3xl font-bold text-stone-800" id="kpi-total-liabilities">0원</p>
                    <div class="mt-2 flex items-center text-sm">
                        <span class="text-rose-600 font-medium"><i class="fa-solid fa-credit-card mr-1"></i>대출 및 부채</span>
                    </div>
                </div>
            </div>

            <!-- Charts Row -->
            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <!-- Main Trend Chart (Spans 2 cols) -->
                <div class="card p-6 lg:col-span-2">
                    <div class="mb-6">
                        <h3 class="text-lg font-bold text-stone-800">자산 변동 그래프</h3>
                    </div>
                    
                    <div class="chart-container relative">
                        <canvas id="netWorthChart"></canvas>
                    </div>
                    
                    <!-- Scroll Slider -->
                    <div class="mt-4 px-2">
                        <input type="range" min="0" max="24" value="24" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-teal-600" id="chartScrollSlider">
                        <div class="flex justify-between text-xs text-stone-400 mt-1">
                            <span id="slider-start-label">시작</span>
                            <span>드래그하여 과거 조회</span>
                            <span id="slider-end-label">현재</span>
                        </div>
                    </div>
                </div>
                
                <!-- Portfolio Mix (Spans 1 col) -->
                <div class="card p-6 relative group hover:border-teal-400 transition-colors">
                    <div class="absolute top-4 right-4 text-stone-300 group-hover:text-teal-500 transition-colors">
                        <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
                    </div>
                    <h3 class="text-lg font-semibold text-stone-800 mb-4">포트폴리오 구성 <span id="asset-month-label" class="text-sm font-normal text-stone-500 ml-2"></span></h3>
                    <div class="chart-container">
                        <canvas id="portfolioChart"></canvas>
                    </div>
                    <div class="mt-4 text-center">
                        <p class="text-xs text-stone-400 group-hover:text-teal-600">클릭하여 상세 비교</p>
                    </div>
                </div>
            </div>

            <!-- ROI & Profit Charts Section -->
            <div class="card p-6 mt-6">
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                    <!-- Col 1: ROI % Trend -->
                    <div>
                        <div class="mb-4">
                             <div class="relative inline-block">
                                <h3 class="text-lg font-bold text-stone-800 cursor-help" id="roi-chart-title">투자 성과 (수익률 %)</h3>
                                <!-- Custom Tooltip -->
                                <div id="roi-custom-tooltip" class="absolute left-0 top-8 z-50 hidden w-80 p-3 bg-stone-800 text-white text-xs rounded shadow-xl opacity-95 pointer-events-none"></div>
                             </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="roiChart"></canvas>
                        </div>
                    </div>

                    <!-- Col 2: Profit Amount Trend -->
                    <div>
                        <div class="mb-4">
                            <h3 class="text-lg font-bold text-stone-800">월별 평가 손익 (부동산 제외)</h3>
                        </div>
                        <div class="chart-container">
                            <canvas id="profitChart"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- Shared Slider -->
                <div class="mt-4 px-2">
                    <input type="range" min="0" max="24" value="24" class="w-full h-2 bg-stone-200 rounded-lg appearance-none cursor-pointer accent-teal-600" id="roiScrollSlider">
                    <div class="flex justify-between text-xs text-stone-400 mt-1">
                        <span id="roi-slider-start-label">시작</span>
                        <span>드래그하여 과거 조회</span>
                        <span id="roi-slider-end-label">현재</span>
                    </div>
                </div>
            </div>
        </section>

        <!-- Tab 2: P&L Dashboard -->
        <section id="tab-pnl" class="hidden space-y-6">
            <div class="bg-amber-50 border-l-4 border-amber-500 p-4 rounded-r shadow-sm">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <i class="fa-solid fa-lightbulb text-amber-500"></i>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-amber-700">
                            <strong>손익 분석 (P&L):</strong> 수입과 지출 내역을 분석합니다. 지출은 고정비(필수)와 변동비(선택)로 구분하여 절약 기회를 찾을 수 있습니다.
                        </p>
                    </div>
                </div>
            </div>

            <!-- P&L Charts -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <!-- Stacked Bar: Expenses -->
                <div class="card p-6">
                    <h3 class="text-lg font-semibold text-stone-800 mb-4">월별 지출 구조</h3>
                    <div class="chart-container">
                        <canvas id="expenseStructureChart"></canvas>
                    </div>

                </div>

                <!-- Expense Categories (Pie or Bar) -->
                <div class="card p-6">
                    <h3 class="text-lg font-semibold text-stone-800 mb-4">주요 지출 카테고리 <span id="pnl-month-label" class="text-sm font-normal text-stone-500 ml-2"></span></h3>
                    <div class="chart-container">
                        <canvas id="categoryBreakdownChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Transaction Details Table -->
            <div class="card overflow-hidden">
                <div class="px-6 py-4 border-b border-stone-200 flex justify-between items-center">
                    <h3 class="text-lg font-semibold text-stone-800">상세 거래 내역</h3>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs text-stone-500 bg-stone-100 px-2 py-1 rounded">지출 Top 5</span>
                        <button onclick="openTransactionModal()" class="text-xs text-teal-600 hover:text-teal-800 font-medium cursor-pointer">더보기 ></button>
                    </div>
                </div>
                <div class="overflow-x-auto">
                    <table class="min-w-full text-left text-sm whitespace-nowrap">
                        <thead class="bg-stone-50 text-stone-500 uppercase tracking-wider">
                            <tr>
                                <th scope="col" class="px-6 py-3 font-medium">날짜</th>
                                <th scope="col" class="px-6 py-3 font-medium">내용</th>
                                <th scope="col" class="px-6 py-3 font-medium">분류</th>
                                <th scope="col" class="px-6 py-3 font-medium">구분</th>
                                <th scope="col" class="px-6 py-3 font-medium text-right">금액</th>
                            </tr>
                        </thead>
                        <tbody id="transactionTableBody" class="divide-y divide-stone-100 bg-white">
                            <!-- Populated by JS -->
                        </tbody>
                    </table>
                </div>
            </div>
        </section>

        <!-- Tab 3: Cash Flow Dashboard -->
        <section id="tab-cashflow" class="hidden space-y-6">
            <div class="bg-emerald-50 border-l-4 border-emerald-500 p-4 rounded-r shadow-sm">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <i class="fa-solid fa-money-bill-wave text-emerald-500"></i>
                    </div>
                    <div class="ml-3">
                        <p class="text-sm text-emerald-700">
                            <strong>현금흐름 분석 :</strong> 미래의 현금 유출입에 대한 예상. 기본적인 수익 및 비용은 3개월 평균으로 반영 중 (PS,PI제외)
                        </p>
                    </div>
                </div>
            </div>

            <!-- Main Cash Flow Chart -->
            <div class="card p-6">
                <h3 class="text-lg font-semibold text-stone-800 mb-4">월별 수입 대 지출 (Inflow vs Outflow)</h3>
                <div class="chart-container h-96">
                    <canvas id="cashFlowChart"></canvas>
                </div>
            </div>


        </section>

    </main>

    <footer class="bg-white border-t border-stone-200 mt-auto">
        <div class="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8">
            <p class="text-center text-xs text-stone-400">
                Generated Prototype based on 'finance_db_schema.md'. <br>
                Data is simulated for demonstration.
            </p>
        </div>
    </footer>

    <!-- MODAL: Portfolio Details & Comparison -->
    <div id="portfolioModal" class="fixed inset-0 z-50 hidden overflow-y-auto" aria-labelledby="modal-title" role="dialog" aria-modal="true">
        <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
            <!-- Background overlay -->
            <div class="fixed inset-0 bg-stone-500 bg-opacity-75 transition-opacity" aria-hidden="true" onclick="closeModal()"></div>

            <span class="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">&#8203;</span>

            <div class="inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-4xl sm:w-full">
                <div class="bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4">
                    <div class="sm:flex sm:items-start">
                        <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left w-full">
                            <h3 class="text-lg leading-6 font-medium text-stone-900" id="modal-title">자산/부채 상세 분석</h3>
                            
                            <!-- Comparison Controls -->
                            <div class="mt-4 flex flex-wrap items-center gap-2 bg-stone-50 p-3 rounded-lg">
                                <span class="text-sm text-stone-600 mr-2">비교 대상: <span class="font-bold" id="modal-current-month"></span> vs</span>
                                
                                <button id="btn-comp-last-month" class="px-3 py-1 text-xs rounded-full bg-white border border-stone-200 text-stone-600 hover:bg-teal-50 hover:text-teal-700 hover:border-teal-200 transition-all shadow-sm">
                                    지난달
                                </button>
                                <button id="btn-comp-last-year" class="px-3 py-1 text-xs rounded-full bg-white border border-stone-200 text-stone-600 hover:bg-teal-50 hover:text-teal-700 hover:border-teal-200 transition-all shadow-sm">
                                    작년 동월
                                </button>

                                <select id="comparisonMonthSelector" class="text-sm border-stone-300 rounded px-2 py-1 ml-auto">
                                    <option value="">직접 선택...</option>
                                    <!-- Options populated via JS -->
                                </select>
                            </div>

                            <div class="mt-6 grid grid-cols-1 md:grid-cols-2 gap-8">
                                <!-- Current Selected Month -->
                                <div>
                                    <h4 class="text-sm font-bold text-center mb-2 text-stone-700" id="lbl-current">현재 (Current)</h4>
                                    <div class="h-64 relative">
                                        <canvas id="modalChartCurrent"></canvas>
                                    </div>
                                    <div id="modalDetailsCurrent" class="mt-4 text-xs text-stone-500 space-y-1"></div>
                                </div>
                                
                                <!-- Comparison Month -->
                                <div id="comparison-section" class="opacity-50">
                                    <h4 class="text-sm font-bold text-center mb-2 text-stone-700" id="lbl-compare">비교 대상 (Comparison)</h4>
                                    <div class="h-64 relative">
                                        <canvas id="modalChartCompare"></canvas>
                                    </div>
                                    <div id="modalDetailsCompare" class="mt-4 text-xs text-stone-500 space-y-1 text-center">비교할 월을 선택하세요.</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="bg-stone-50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
                    <button type="button" class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-teal-600 text-base font-medium text-white hover:bg-teal-700 focus:outline-none sm:ml-3 sm:w-auto sm:text-sm" onclick="closeModal()">닫기</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- MODAL: All Transactions -->
    <div id="transactionModal" class="fixed inset-0 z-50 hidden overflow-y-auto" aria-labelledby="modal-title" role="dialog" aria-modal="true">
        <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
            <div class="fixed inset-0 bg-stone-500 bg-opacity-75 transition-opacity" aria-hidden="true" onclick="closeTransactionModal()"></div>
            <span class="hidden sm:inline-block sm:align-middle sm:h-screen" aria-hidden="true">&#8203;</span>
            <div class="inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-4xl sm:w-full">
                <div class="bg-white px-4 pt-5 pb-4 sm:p-6 sm:pb-4 h-[70vh] flex flex-col">
                    <div class="sm:flex sm:items-start flex-grow overflow-hidden flex-col">
                        <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left w-full flex-grow flex flex-col">
                            <div class="flex flex-col md:flex-row md:items-center justify-between mb-4 space-y-2 md:space-y-0">
                                <h3 class="text-lg leading-6 font-medium text-stone-900" id="trans-modal-title">전체 거래 내역</h3>
                                
                                <div class="flex items-center space-x-4">
                                    <!-- Filter Tabs -->
                                    <div class="inline-flex rounded-md shadow-sm" role="group">
                                        <button onclick="setTransFilter('All')" id="btn-trans-all" class="px-3 py-1 text-xs font-medium rounded-l-lg border border-stone-200 bg-teal-50 text-teal-700 hover:bg-stone-50">전체</button>
                                        <button onclick="setTransFilter('Income')" id="btn-trans-income" class="px-3 py-1 text-xs font-medium border-t border-b border-r border-stone-200 bg-white text-stone-600 hover:bg-stone-50">수입</button>
                                        <button onclick="setTransFilter('Expense')" id="btn-trans-expense" class="px-3 py-1 text-xs font-medium rounded-r-lg border-t border-b border-r border-stone-200 bg-white text-stone-600 hover:bg-stone-50">지출</button>
                                    </div>
                                    
                                    <!-- Sort Selector -->
                                    <select onchange="renderTransactionModalTable()" id="trans-sort-select" class="text-xs border-stone-300 rounded px-2 py-1">
                                        <option value="date-desc">날짜 최신순</option>
                                        <option value="date-asc">날짜 과거순</option>
                                        <option value="amount-desc">금액 높은순</option>
                                        <option value="amount-asc">금액 낮은순</option>
                                    </select>
                                </div>
                            </div>
                            
                            <div class="overflow-auto flex-grow border border-stone-200 rounded-lg">
                                <table class="min-w-full text-left text-sm whitespace-nowrap relative">
                                    <thead class="bg-stone-50 text-stone-500 uppercase tracking-wider sticky top-0 z-10">
                                        <tr>
                                            <th scope="col" class="px-6 py-3 font-medium bg-stone-50">날짜</th>
                                            <th scope="col" class="px-6 py-3 font-medium bg-stone-50">내용</th>
                                            <th scope="col" class="px-6 py-3 font-medium bg-stone-50">분류</th>
                                            <th scope="col" class="px-6 py-3 font-medium bg-stone-50">구분</th>
                                            <th scope="col" class="px-6 py-3 font-medium text-right bg-stone-50">금액</th>
                                        </tr>
                                    </thead>
                                    <tbody id="fullTransactionTableBody" class="divide-y divide-stone-100 bg-white">
                                        <!-- Populated by JS -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="bg-stone-50 px-4 py-3 sm:px-6 sm:flex sm:flex-row-reverse">
                    <button type="button" class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-teal-600 text-base font-medium text-white hover:bg-teal-700 focus:outline-none sm:ml-3 sm:w-auto sm:text-sm" onclick="closeTransactionModal()">닫기</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 0. SETUP CHART.JS PLUGINS ---
        if (typeof ChartDataLabels !== 'undefined') {
            Chart.register(ChartDataLabels);
            // 기본적으로 모든 차트에서 숨김 처리 (포트폴리오 차트에서만 덮어씌워서 켤 예정)
            Chart.defaults.set('plugins.datalabels', { display: false });
        }

        // --- 1. DATA VARIABLES (Populated via API) ---
        let months = []; // Will be populated from sheetData
        let monthlyBalances = []; 
        let transactions = [];
        let cashflowPlans = []; // Mapping for DB_Cashflow 

        // --- 2. STATE MANAGEMENT ---
        // Global State
        const state = {
            currentTab: 'assets',
            selectedMonth: new Date().toISOString().slice(0, 7),
            sliderStart: 0,
            roiSliderStart: 0,
            includePension: false, // Default: Exclude Pension
            currentTransFilter: 'All', // 'All', 'Income', 'Expense'
            charts: {},
            lastUpdated: null
        };

        // Shared Color Management
        const assetColorMap = {};
        const globalPalette = ['#0d9488', '#0ea5e9', '#8b5cf6', '#f43f5e', '#f59e0b', '#10b981', '#6366f1', '#ec4899', '#14b8a6', '#f97316', '#3b82f6', '#ef4444'];
        
        function assignAssetColors(data) {
            // Collect all unique asset names
            const allAssetNames = Array.from(new Set(data.map(b => b.name))).sort();
            allAssetNames.forEach((name, index) => {
                if (!assetColorMap[name]) {
                     assetColorMap[name] = globalPalette[index % globalPalette.length];
                }
            });
        }

        function getAssetColor(name) {
            return assetColorMap[name] || '#9ca3af'; // Default Grey
        }

        // --- 3. DOM ELEMENTS ---
        const monthSelector = document.getElementById('monthSelector');
        const pensionToggle = document.getElementById('pensionToggle');
        const tabButtons = document.querySelectorAll('.tab-btn');
        const sections = {
            assets: document.getElementById('tab-assets'),
            pnl: document.getElementById('tab-pnl'),
            cashflow: document.getElementById('tab-cashflow'),
            chartSlider: document.getElementById('chartScrollSlider'), // New Slider
            modal: document.getElementById('portfolioModal'),
            compSelect: document.getElementById('comparisonMonthSelector')
        };
        const kpiElements = {
            netWorth: document.getElementById('kpi-net-worth'),
            assets: document.getElementById('kpi-total-assets'),
            liabilities: document.getElementById('kpi-total-liabilities'),
            cfIncome: document.getElementById('cf-income'),
            cfExpense: document.getElementById('cf-expense'),
            cfNet: document.getElementById('cf-net'),
            cfBadge: document.getElementById('cf-status-badge')
        };
        const tableBody = document.getElementById('transactionTableBody');

        // --- 4. FORMATTING HELPERS ---
        const formatCurrency = (num) => {
            return new Intl.NumberFormat('ko-KR', { style: 'decimal' }).format(num) + '원';
        };

        async function init() {
            try {
                // 1. Vercel 서버리스 함수를 통해 데이터 가져오기 (보안 강화)
                const response = await fetch('/api/data');
                const sheetData = await response.json();
                
                console.log("로드된 Raw 데이터:", sheetData);

                // 2. 데이터 매핑 및 가공 (Data Transformation)
                
                // (A) Asset Info Map 생성 (AssetID -> Info)
                const assetMap = {};
                if (sheetData.assets) {
                    sheetData.assets.forEach(a => {
                        assetMap[a.AssetID] = {
                            category: a.Category,     // 예: 주식, 예금
                            type: a.AssetType,        // 예: 금융자산, 실물자산
                            name: a.AssetName         // 예: 삼성전자
                        };
                    });
                }

                // (B) Balance Sheet 매핑 (balance + assetMap -> monthlyBalances)
                // 데이터 구조: { Date, AssetID, "EvaluationValue (평가금액)", "Debt (부채)", ... }
                monthlyBalances = [];
                if (sheetData.balance) {
                    // 유효한 행만 필터링 및 최신 데이터 추출
                    const latestRecords = new Map(); // Key: month + AssetID

                    sheetData.balance.forEach(row => {
                        let rawDate = row.Date;
                        if (!rawDate) return;
                        
                        let monthStr = "";
                        if (typeof rawDate === 'string') {
                            monthStr = rawDate.substring(0, 7);
                        } else {
                            try {
                                monthStr = new Date(rawDate).toISOString().slice(0, 7);
                            } catch (e) { return; }
                        }

                        const key = `${monthStr}_${row.AssetID}`;
                        const existing = latestRecords.get(key);
                        
                        // 같은 달, 같은 자산ID인 경우 날짜(Date)가 더 최신인 것을 선택
                        // row.Date가 문자열 또는 날짜 객체여도 비교 가능하도록 처리
                        if (!existing || new Date(row.Date) >= new Date(existing.Date)) {
                            latestRecords.set(key, row);
                        }
                    });

                    // 최신 데이터만 monthlyBalances에 추가
                    Array.from(latestRecords.values()).forEach(row => {
                        let rawDate = row.Date;
                        let monthStr = typeof rawDate === 'string' ? rawDate.substring(0, 7) : new Date(rawDate).toISOString().slice(0, 7);

                        const info = assetMap[row.AssetID] || { category: '기타', type: '기타', name: row.vlookup || 'Unknown' };
                        
                        const evalValue = Number(row["EvaluationValue (평가금액)"]) || 0;
                        const debtValue = Number(row["Debt (부채)"]) || 0;
                        const costValue = Number(row["Principal (투자원금)"]) || 0;

                        if (evalValue > 0 || (row.AssetID && row.AssetID.startsWith('A') && evalValue === 0)) { 
                           monthlyBalances.push({
                               month: monthStr,
                               category: info.category, 
                               subType: info.type,      
                               type: 'Asset',
                               amount: evalValue,
                               cost: costValue, 
                               name: info.name
                           });
                        }

                        if (debtValue > 0) {
                             monthlyBalances.push({
                               month: monthStr,
                               category: info.category,
                               subType: info.type,
                               type: 'Liability',
                               amount: debtValue,
                               name: info.name
                           });
                        }
                    });
                }

                // (C) Transactions 매핑 (is -> transactions)
                // 데이터 구조: { Date, Type(수입/지출), Category, Amount, Item }
                transactions = [];
                if (sheetData.is) {
                    sheetData.is.forEach(row => {
                        // 날짜 (Robust Parsing)
                        let rawDate = row.Date;
                        let dateStr = "";
                        if (rawDate) {
                            if (typeof rawDate === 'string') {
                                dateStr = rawDate.substring(0, 10);
                            } else {
                                try {
                                    dateStr = new Date(rawDate).toISOString().slice(0, 10);
                                } catch (e) { dateStr = ""; }
                            }
                        }

                        // 타입 변환 (수입->Income, 지출->Expense)
                        let type = "Expense";
                        if (row.Type === "수입") type = "Income";
                        else if (row.Type === "지출") type = "Expense";

                        // 고정/변동 매핑 (Category or Item에 힌트가 있을 수 있음, 일단 'n/a' 처리하거나 로직추가)
                        // 시트 데이터에 'Category'가 '고정비', '변동비' 등으로 들어오면 매핑 가능
                        // 현재 시트 예시: Category="고정비", Item="아파트 관리비"
                        let costType = "Variable"; 
                        if (row.Category === "고정비") costType = "Fixed";

                        transactions.push({
                            date: dateStr,
                            type: type,
                            category: row.Item || row.Category, // 카테고리 대신 구체적인 항목명 사용 (예: 외식비)
                            costType: costType, 
                            description: row.Item,
                            amount: Number(row.Amount) || 0
                        });
                    });
                }

                // (D) Cash Flow Plans 매핑 (이미지 기반 헤더 매칭)
                cashflowPlans = [];
                const cfKey = Object.keys(sheetData).find(k => 
                    ['cashflow', 'db_cashflow', 'dbcashflow', '현금흐름계획'].includes(k.toLowerCase())
                );
                const cfRawData = cfKey ? sheetData[cfKey] : null;

                if (cfRawData) {
                    console.log(`[Cashflow] '${cfKey}' 시트 데이터 처리 시작...`);
                    cfRawData.forEach((row, idx) => {
                        // 1. 날짜 추출 (예정일 (DueDate))
                        let rawDate = row['예정일 (DueDate)'] || row.DueDate || row.Date || row.Month || row['날짜'];
                        let monthStr = "";
                        if (rawDate) {
                            const dStr = String(rawDate).trim();
                            if (dStr.includes('-')) monthStr = dStr.substring(0, 7); 
                            else {
                                try { monthStr = new Date(rawDate).toISOString().slice(0, 7); } catch(e) {}
                            }
                        }
                        
                        // 2. 금액 및 구분 추출 (예정금액 (Amount), 구분)
                        const amount = Number(String(row['예정금액 (Amount)'] || row.Amount || row['금액'] || 0).replace(/,/g, ''));
                        const rawType = String(row['구분'] || row['Type'] || '').toLowerCase();
                        const type = (rawType === 'income' || rawType === '현금유입') ? 'Income' : 'Expense';
                        
                        const item = row['항목 (Item)'] || row.Item || row['항목'] || '';

                        if (monthStr && amount !== 0) {
                            cashflowPlans.push({ month: monthStr, type: type, item: item, amount: amount });
                        }
                    });
                    console.log("[Cashflow] 최종 로드된 계획 수:", cashflowPlans.length, cashflowPlans);
                } else {
                    console.warn("[Cashflow] 시트를 찾을 수 없습니다.");
                }

                console.log("SheetData Keys:", Object.keys(sheetData));
                console.log("가공된 Balances:", monthlyBalances);
                console.log("가공된 Transactions:", transactions);

                // Initialize Colors
                assignAssetColors(monthlyBalances);

                // 3. 월 선택기(Selector) 생성 및 초기화
                renderMonthSelector(); 

                // 4. 대시보드 업데이트
                updateDashboard();
                
            } catch (error) {
                console.error("데이터 로드 중 에러 발생:", error);
                alert("시트 데이터를 불러오지 못했습니다. 콘솔을 확인하세요.\n" + error.message);
            }

            // Event Listeners (UI Only)
            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    tabButtons.forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    Object.values(sections).forEach(sec => sec.classList.add('hidden'));
                    const target = btn.dataset.tab;
                    state.currentTab = target;
                    sections[target].classList.remove('hidden');
                    updateDashboard();
                });
            });
        }

        function renderMonthSelector() {
            // Extract unique months from monthlyBalances ONLY (db_balance)
            const uniqueMonths = new Set();
            monthlyBalances.forEach(b => uniqueMonths.add(b.month));
            // transactions loop removed to rely solely on balance sheet dates

            // Convert to array and sort
            months = Array.from(uniqueMonths).sort();

            // Populate Selector
            monthSelector.innerHTML = '';
            months.forEach(m => {
                const option = document.createElement('option');
                option.value = m;
                option.textContent = m; 
                monthSelector.appendChild(option);
            });

            // Helper to update slider labels
            const updateSliderLabels = (sliderElem, startId, endId) => {
                const val = parseInt(sliderElem.value);
                // val is the End Index
                // Window size is 12 (hardcoded roughly in logic)
                // Start Index = val - 11
                
                let endMonth = months[Math.min(val, months.length-1)];
                let startMonth = months[Math.max(0, val - 11)];

                if(endMonth) document.getElementById(endId).textContent = endMonth;
                if(startMonth) document.getElementById(startId).textContent = startMonth;
            };

            // Set Initial State Logic
            if (months.length > 0) {
                // Default to latest month
                state.selectedMonth = months[months.length - 1];
                monthSelector.value = state.selectedMonth;
                // Update slider max/value
                // Asset Trend Slider
                const slider = document.getElementById('chartScrollSlider');
                if(slider) {
                    slider.max = Math.max(0, months.length - 1); // Max value is the index of the last month
                    slider.value = slider.max; // Default: Show latest
                    state.sliderStart = Math.max(0, months.length - 12); // Default show last 12 months window
                    
                    // Initial Label Update
                    updateSliderLabels(slider, 'slider-start-label', 'slider-end-label');

                    slider.addEventListener('input', (e) => {
                        const val = parseInt(e.target.value);
                        const windowSize = 12;
                        state.sliderStart = Math.max(0, val - windowSize + 1); // Calculate start index for a 12-month window ending at 'val'
                        updateDashboard(); 
                        updateSliderLabels(e.target, 'slider-start-label', 'slider-end-label');
                    });
                }

                // ROI Chart Slider
                const roiSlider = document.getElementById('roiScrollSlider');
                if(roiSlider) {
                    roiSlider.max = Math.max(0, months.length - 1); // Max value is the index of the last month
                    roiSlider.value = roiSlider.max;
                    state.roiSliderStart = Math.max(0, months.length - 12); // Default show last 12 months window
                    updateSliderLabels(roiSlider, 'roi-slider-start-label', 'roi-slider-end-label');

                    roiSlider.addEventListener('input', (e) => {
                        const val = parseInt(e.target.value);
                        const windowSize = 12;
                        state.roiSliderStart = Math.max(0, val - windowSize + 1); 
                        renderROI(); 
                        renderProfitChart(); // Update Profit Chart too
                        updateSliderLabels(roiSlider, 'roi-slider-start-label', 'roi-slider-end-label');
                    });
                }
            }

            // Add Listener
            monthSelector.addEventListener('change', (e) => {
                state.selectedMonth = e.target.value;
                updateDashboard(); // 슬라이더는 그대로 두고 대시보드만 업데이트
            });

            // Pension Toggle Listener
            const pToggle = document.getElementById('pensionToggle');
            if(pToggle) {
                pToggle.addEventListener('change', (e) => {
                    state.includePension = e.target.checked;
                    updateDashboard();
                });
            }
        }

        // --- NEW: Time Range Handler ---
        sections.chartSlider.addEventListener('input', (e) => {
            state.sliderStart = parseInt(e.target.value, 10);
            renderAssets();
        });

        // --- MODAL LOGIC (Generalized) ---
        let currentModalType = 'Asset';

        window.openBreakdownModal = (type) => {
            currentModalType = type;
            sections.modal.classList.remove('hidden');
            document.getElementById('modal-current-month').textContent = state.selectedMonth;
            
            // Set Title based on type
            const titles = {
                'Asset': '총자산 구성 (Asset Allocation)',
                'Liability': '총부채 구성 (Liability Breakdown)',
                'NetWorth': '순자산 현황 (Net Worth Analysis)',
                'Income': '수입 상세 (Income Breakdown)',
                'Fixed': '고정 지출 상세 (Fixed Costs)',
                'Variable': '변동 지출 상세 (Variable Costs)'
            };
            document.getElementById('modal-title').textContent = titles[type] || 'Detailed View';

            // 1. Calculate Quick Compare Targets
            const currentIndex = months.indexOf(state.selectedMonth);
            let prevMonth = (currentIndex > 0) ? months[currentIndex - 1] : null;
            
            // Calculate Last Year Same Month
            // Format: YYYY-MM. Split, minus 1 year, join.
            const [currYear, currMon] = state.selectedMonth.split('-');
            const lastYearStr = `${Number(currYear) - 1}-${currMon}`;
            const lastYearMonth = months.includes(lastYearStr) ? lastYearStr : null;

            // 2. Setup Buttons
            const btnLastMonth = document.getElementById('btn-comp-last-month');
            const btnLastYear = document.getElementById('btn-comp-last-year');

            // Reset Button Styles (helper)
            const resetBtns = () => {
                [btnLastMonth, btnLastYear].forEach(b => b.classList.remove('bg-teal-100', 'text-teal-800', 'border-teal-300'));
            };

            // Enable/Disable & Click Handlers
            if (prevMonth) {
                btnLastMonth.disabled = false;
                // Handler assigned below
            } else {
                btnLastMonth.disabled = true;
                btnLastMonth.classList.add('opacity-50', 'cursor-not-allowed');
            }

            if (lastYearMonth) {
                btnLastYear.disabled = false;
                // Handler assigned below
            } else {
                btnLastYear.disabled = true;
                btnLastYear.classList.add('opacity-50', 'cursor-not-allowed');
            }

            // 3. Populate Select Box
            sections.compSelect.innerHTML = '<option value="">직접 선택...</option>';
            months.forEach(m => {
                if(m !== state.selectedMonth) {
                    const opt = document.createElement('option');
                    opt.value = m;
                    opt.textContent = m;
                    // Auto-select logic moved to buttons or default action below
                    sections.compSelect.appendChild(opt); 
                }
            });

            // 4. Initial Action: Default to Prev Month if available
            // 4. Initial Action: Default to Prev Month if available
            // Helper to dispatch render
            const render = (curr, comp, t) => {
                if (['Fixed', 'Variable', 'Income'].includes(t)) {
                    showCashFlowDetails(curr, comp, t);
                } else {
                    renderModalCharts(curr, comp, t);
                }
            };

            if (prevMonth) {
                // Manually trigger the click logic
                resetBtns();
                btnLastMonth.classList.add('bg-teal-100', 'text-teal-800', 'border-teal-300');
                sections.compSelect.value = prevMonth;
                render(state.selectedMonth, prevMonth, type);
            } else {
                render(state.selectedMonth, null, type);
            }

            // Update Handlers with Dispatcher
             if (prevMonth) {
                btnLastMonth.onclick = () => {
                    resetBtns();
                    btnLastMonth.classList.add('bg-teal-100', 'text-teal-800', 'border-teal-300');
                    sections.compSelect.value = prevMonth;
                    render(state.selectedMonth, prevMonth, type);
                };
            }
             if (lastYearMonth) {
                btnLastYear.onclick = () => {
                    resetBtns();
                    btnLastYear.classList.add('bg-teal-100', 'text-teal-800', 'border-teal-300');
                    sections.compSelect.value = lastYearMonth;
                    render(state.selectedMonth, lastYearMonth, type);
                };
            }
        };
        
        window.closeModal = () => {
            sections.modal.classList.add('hidden');
            sections.compSelect.value = "";
            // Clear Charts to save memory
             if(state.charts['modalChartCurrent']) state.charts['modalChartCurrent'].destroy();
             if(state.charts['modalChartCompare']) state.charts['modalChartCompare'].destroy();
        };

        sections.compSelect.addEventListener('change', (e) => {
            const compareMonth = e.target.value;
            if (['Fixed', 'Variable', 'Income'].includes(currentModalType)) {
                showCashFlowDetails(state.selectedMonth, compareMonth, currentModalType);
            } else {
                renderModalCharts(state.selectedMonth, compareMonth, currentModalType);
            }
        });

        function renderModalCharts(currentM, compareM, type) {
            // Helper: Filter data based on type
            const getData = (m) => {
                const bal = monthlyBalances.filter(b => {
                    if (b.month !== m) return false;
                    // Pension Filter Check
                    if (!state.includePension && b.subType && b.subType.includes('연금')) return false;
                    return true;
                });
                const cat = {};
                
                if (type === 'NetWorth') {
                    // 순자산의 경우: 자산 vs 부채 총합 비교
                    cat['Total Assets'] = bal.filter(b => b.type === 'Asset').reduce((s,b)=>s+b.amount,0);
                    cat['Total Liabilities'] = bal.filter(b => b.type === 'Liability').reduce((s,b)=>s+b.amount,0);
                } else if (type.startsWith('Category:')) {
                    // **NEW: Category Drill-down**
                    const info = type.split(':');
                    const targetCat = info[1]; // e.g. '부동산'
                    document.getElementById('modal-title').textContent = `${targetCat} 상세 내역`;
                    
                    // Filter: Match Category AND Type must be 'Asset' (Exclude Debts)
                    bal.filter(b => b.category === targetCat && b.type === 'Asset').forEach(b => {
                         cat[b.name] = (cat[b.name] || 0) + b.amount;
                    });

                } else {
                    // 자산 또는 부채 상세 (General)
                    const targetType = type; // 'Asset' or 'Liability'
                    bal.filter(b => b.type === targetType).forEach(b => {
                        // 카테고리별 합계
                        cat[b.category] = (cat[b.category] || 0) + b.amount;
                    });
                }
                return cat;
            };

            const currentData = getData(currentM);
            // Prepare Compare Data Early for Diff Calculation
            const compareData = compareM ? getData(compareM) : {};

            const detailCurrentDiv = document.getElementById('modalDetailsCurrent');
            
            // Common DataLabels Config
            const dataLabelConfig = {
                color: '#ffffff',
                font: { 
                    family: "'Inter', sans-serif",
                    weight: '600', 
                    size: 13 
                },
                textStrokeColor: 'rgba(0,0,0,0.2)',
                textStrokeWidth: 3,
                textShadowBlur: 4,
                textShadowColor: 'rgba(0, 0, 0, 0.3)',
                formatter: (value, ctx) => {
                    let sum = 0;
                    let dataArr = ctx.chart.data.datasets[0].data;
                    dataArr.map(data => { sum += data; });
                    let percentage = (value*100 / sum).toFixed(1)+"%";
                    return percentage; 
                },
                display: (context) => {
                    let value = context.dataset.data[context.dataIndex];
                    let sum = context.dataset.data.reduce((a, b) => a + b, 0);
                    return (value / sum) > 0.05; // > 5% only
                },
                anchor: 'center',
                align: 'center',
                offset: 0
            };

            // 1. Prepare Data Union for List Alignment 
            // We want to list ALL keys from both sets to allow row-by-row comparison
            const allKeysSet = new Set([...Object.keys(currentData), ...Object.keys(compareData)]);
            const allKeys = Array.from(allKeysSet).sort();

            // 2. Render Current Chart (Keep chart strictly to current composition)
            renderChart('modalChartCurrent', 'doughnut', {
                labels: Object.keys(currentData),
                datasets: [{
                    data: Object.values(currentData),
                    backgroundColor: ['#14b8a6', '#f43f5e', '#0ea5e9', '#8b5cf6', '#f59e0b', '#10b981'] 
                }]
            }, {
                plugins: {
                    legend: { position: 'bottom', labels: { boxWidth: 10, font: { size: 10 } } }, 
                    datalabels: dataLabelConfig 
                }
            }, [ChartDataLabels]);
            
            // 3. Render Current List (Using Unified Keys)
            const totalCurrent = Object.values(currentData).reduce((a, b) => a + b, 0);
            
            detailCurrentDiv.innerHTML = allKeys.map(k => {
                const v = currentData[k] || 0;
                const prevValue = compareData[k] || 0;

                // Skip if both zero (edge case)
                if (v === 0 && prevValue === 0) return '';

                const pct = totalCurrent > 0 ? ((v / totalCurrent) * 100).toFixed(1) + '%' : '0%';
                
                // Diff Logic 
                let diffHtml = '';
                if (compareM) {
                    const diff = v - prevValue;
                    const diffClass = diff >= 0 ? 'text-teal-600' : 'text-rose-500';
                    const diffIcon = diff >= 0 ? '▲' : '▼';
                    // Show diff if there IS a difference
                    if (diff !== 0) {
                        diffHtml = `
                            <div class="text-xs ${diffClass} mt-0.5 text-right w-full">
                                ${diffIcon} ${formatCurrency(Math.abs(diff))}
                            </div>
                        `;
                    }
                }

                // Visual cue for row: if v is 0, gray out slightly
                const rowClass = v === 0 ? 'opacity-60' : '';

                return `
                <div class="flex justify-between items-center border-b border-stone-100 py-2 ${rowClass}" style="min-height: 53px;">
                    <span class="font-medium text-stone-600 truncate pr-2">${k}</span>
                    <div class="flex flex-col items-end shrink-0">
                        <div>
                            <span class="font-bold text-stone-800">${formatCurrency(v)}</span>
                            <span class="text-xs text-stone-400 ml-1">(${pct})</span>
                        </div>
                        ${diffHtml}
                    </div>
                </div>`;
            }).join('');


            // 4. Render Compare Chart & List
            const detailCompareDiv = document.getElementById('modalDetailsCompare');
            const compareSection = document.getElementById('comparison-section');

            if (compareM) {
                compareSection.classList.remove('opacity-50');
                document.getElementById('lbl-compare').textContent = `비교 대상: ${compareM}`;
                
                renderChart('modalChartCompare', 'doughnut', {
                    labels: Object.keys(compareData),
                    datasets: [{
                        data: Object.values(compareData),
                        backgroundColor: ['#14b8a6', '#f43f5e', '#0ea5e9', '#8b5cf6', '#f59e0b', '#10b981']
                    }]
                }, {
                    plugins: {
                        legend: { position: 'bottom', labels: { boxWidth: 10, font: { size: 10 } } },
                        datalabels: dataLabelConfig 
                    }
                }, [ChartDataLabels]);
                
                const totalCompare = Object.values(compareData).reduce((a, b) => a + b, 0);

                // Compare List (Aligned with Current List via allKeys)
                detailCompareDiv.innerHTML = allKeys.map(k => {
                    const v = compareData[k] || 0;
                    const valInCurrent = currentData[k] || 0;
                    
                    if (v === 0 && valInCurrent === 0) return '';

                    const pct = totalCompare > 0 ? ((v / totalCompare) * 100).toFixed(1) + '%' : '0%';
                    const rowOpacity = v === 0 ? 'opacity-30' : '';

                    // If value is 0 (didn't exist then), maybe show '-'
                    const valDisplay = v === 0 ? '<span class="text-stone-300">-</span>' : formatCurrency(v);
                    const pctDisplay = v === 0 ? '' : `<span class="text-xs text-stone-400 ml-1">(${pct})</span>`;

                    return `
                    <div class="flex justify-between items-center border-b border-stone-100 py-2 ${rowOpacity}" style="min-height: 53px;">
                        <span class="truncate pr-2">${k}</span>
                        <div class="whitespace-nowrap">
                            <span class="font-medium text-stone-700">${valDisplay}</span>
                            ${pctDisplay}
                        </div>
                    </div>`;
                }).join('');

            } else {
                compareSection.classList.add('opacity-50');
                if(state.charts['modalChartCompare']) state.charts['modalChartCompare'].destroy();
                detailCompareDiv.textContent = "Select a month to compare...";
            }
        }

        // --- 5.1. DETAIL MODAL (TRANSACTIONS) ---
        function showCashFlowDetails(currentM, compareM, type) {
            
             // Create title map
             const titleMap = {
                'Income': '총 수입',
                'Fixed': '고정비',
                'Variable': '변동비'
            };

            const title = titleMap[type] || type;

            document.getElementById('modal-title').textContent = `${title} 상세 내역 (${currentM})`;
            
            // Helper: Get Breakdown Data
            const getBreakdown = (m) => {
                const breakdown = {};
                transactions.filter(t => t.date.startsWith(m)).forEach(t => {
                    let include = false;
                    if (type === 'Income' && t.type === 'Income') include = true;
                    else if (type === 'Fixed' && t.type === 'Expense' && t.costType === 'Fixed') include = true;
                    else if (type === 'Variable' && t.type === 'Expense' && t.costType === 'Variable') include = true;

                    if (include) {
                        // Use Category or Description if category is generic
                        const key = t.category; 
                        breakdown[key] = (breakdown[key] || 0) + t.amount;
                    }
                });
                return breakdown;
            };

            const currentData = getBreakdown(currentM);
            const compareData = compareM ? getBreakdown(compareM) : {};

            const detailCurrentDiv = document.getElementById('modalDetailsCurrent');
            
            // Re-use Config
            const dataLabelConfig = {
                color: '#ffffff',
                font: { family: "'Inter', sans-serif", weight: '600', size: 13 },
                textStrokeColor: 'rgba(0,0,0,0.2)',
                textStrokeWidth: 3,
                textShadowBlur: 4,
                textShadowColor: 'rgba(0, 0, 0, 0.3)',
                formatter: (value, ctx) => {
                    let sum = 0;
                    let dataArr = ctx.chart.data.datasets[0].data;
                    dataArr.map(data => { sum += data; });
                    return (value*100 / sum).toFixed(1)+"%";
                },
                display: (context) => {
                    let value = context.dataset.data[context.dataIndex];
                    let sum = context.dataset.data.reduce((a, b) => a + b, 0);
                    return (value / sum) > 0.05; 
                },
                anchor: 'center', align: 'center', offset: 0
            };

            // 1. Render Current Chart
            if(state.charts['modalChartCurrent']) state.charts['modalChartCurrent'].destroy();
            state.charts['modalChartCurrent'] = new Chart(document.getElementById('modalChartCurrent'), {
                type: 'doughnut',
                data: {
                    labels: Object.keys(currentData),
                    datasets: [{
                        data: Object.values(currentData),
                        backgroundColor: ['#14b8a6', '#f43f5e', '#0ea5e9', '#8b5cf6', '#f59e0b', '#10b981', '#6366f1', '#ec4899'] 
                    }]
                },
                options: {
                    responsive: true, maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom', labels: { boxWidth: 10, font: { size: 10 } } }, 
                        datalabels: dataLabelConfig 
                    }
                },
                plugins: [ChartDataLabels]
            });
            
            // 2. Render Current List (Aligned)
            const allKeysSet = new Set([...Object.keys(currentData), ...Object.keys(compareData)]);
            const allKeys = Array.from(allKeysSet).sort();
            const totalCurrent = Object.values(currentData).reduce((a, b) => a + b, 0);
            
            detailCurrentDiv.innerHTML = allKeys.map(k => {
                const v = currentData[k] || 0;
                const prevValue = compareData[k] || 0;
                if (v === 0 && prevValue === 0) return '';

                const pct = totalCurrent > 0 ? ((v / totalCurrent) * 100).toFixed(1) + '%' : '0%';
                
                let diffHtml = '';
                if (compareM) {
                    const diff = v - prevValue;
                    const diffClass = diff >= 0 ? 'text-teal-600' : 'text-rose-500'; // Increase is teal 
                    const diffIcon = diff >= 0 ? '▲' : '▼';
                    if (diff !== 0) {
                        diffHtml = `<div class="text-xs ${diffClass} mt-0.5 text-right w-full">${diffIcon} ${formatCurrency(Math.abs(diff))}</div>`;
                    }
                }
                const rowClass = v === 0 ? 'opacity-60' : '';

                return `
                <div class="flex justify-between items-center border-b border-stone-100 py-2 ${rowClass}" style="min-height: 53px;">
                    <span class="font-medium text-stone-600 truncate pr-2">${k}</span>
                    <div class="flex flex-col items-end shrink-0">
                        <div>
                            <span class="font-bold text-stone-800">${formatCurrency(v)}</span>
                            <span class="text-xs text-stone-400 ml-1">(${pct})</span>
                        </div>
                        ${diffHtml}
                    </div>
                </div>`;
            }).join('');

            // 3. Render Compare Chart & List
            const detailCompareDiv = document.getElementById('modalDetailsCompare');
            const compareSection = document.getElementById('comparison-section');

            if (compareM) {
                compareSection.classList.remove('opacity-50');
                document.getElementById('lbl-compare').textContent = `비교 대상: ${compareM}`;
                
                if(state.charts['modalChartCompare']) state.charts['modalChartCompare'].destroy();
                state.charts['modalChartCompare'] = new Chart(document.getElementById('modalChartCompare'), {
                    type: 'doughnut',
                    data: {
                        labels: Object.keys(compareData),
                        datasets: [{
                            data: Object.values(compareData),
                            backgroundColor: ['#14b8a6', '#f43f5e', '#0ea5e9', '#8b5cf6', '#f59e0b', '#10b981', '#6366f1', '#ec4899']
                        }]
                    },
                    options: {
                        responsive: true, maintainAspectRatio: false,
                        plugins: {
                            legend: { position: 'bottom', labels: { boxWidth: 10, font: { size: 10 } } },
                            datalabels: dataLabelConfig 
                        }
                    },
                    plugins: [ChartDataLabels]
                });
            
            const totalCompare = Object.values(compareData).reduce((a, b) => a + b, 0);

            detailCompareDiv.innerHTML = allKeys.map(k => {
                const v = compareData[k] || 0;
                const valInCurrent = currentData[k] || 0;
                if (v === 0 && valInCurrent === 0) return '';

                const pct = totalCompare > 0 ? ((v / totalCompare) * 100).toFixed(1) + '%' : '0%';
                const rowOpacity = v === 0 ? 'opacity-30' : '';
                const valDisplay = v === 0 ? '<span class="text-stone-300">-</span>' : formatCurrency(v);
                const pctDisplay = v === 0 ? '' : `<span class="text-xs text-stone-400 ml-1">(${pct})</span>`;

                return `
                <div class="flex justify-between items-center border-b border-stone-100 py-2 ${rowOpacity}" style="min-height: 53px;">
                    <span class="truncate pr-2">${k}</span>
                    <div class="whitespace-nowrap">
                        <span class="font-medium text-stone-700">${valDisplay}</span>
                        ${pctDisplay}
                    </div>
                </div>`;
            }).join('');
        } else {
            compareSection.classList.add('opacity-50');
            if(state.charts['modalChartCompare']) state.charts['modalChartCompare'].destroy();
            detailCompareDiv.textContent = "Select a month to compare...";
        }
    }

    // --- 5.2 DETAIL MODAL (FULL TRANSACTIONS) ---
    window.setTransFilter = (filterType) => {
        state.currentTransFilter = filterType;
        
        // Update Button UI
        document.querySelectorAll('[id^="btn-trans-"]').forEach(btn => {
            btn.classList.remove('bg-teal-50', 'text-teal-700');
            btn.classList.add('bg-white', 'text-stone-600');
        });
        const activeBtn = document.getElementById(`btn-trans-${filterType.toLowerCase()}`);
        if(activeBtn) activeBtn.classList.add('bg-teal-50', 'text-teal-700');
        
        renderTransactionModalTable();
    };

    window.renderTransactionModalTable = () => {
        const tbody = document.getElementById('fullTransactionTableBody');
        const sortSelect = document.getElementById('trans-sort-select');
        if (!tbody || !sortSelect) return;

        const sortVal = sortSelect.value;
        tbody.innerHTML = '';
        
        // 1. Filter
        let filteredTrans = transactions.filter(t => t.date && typeof t.date === 'string' && t.date.startsWith(state.selectedMonth));
        if (state.currentTransFilter === 'Income') {
            filteredTrans = filteredTrans.filter(t => t.type === 'Income');
        } else if (state.currentTransFilter === 'Expense') {
            filteredTrans = filteredTrans.filter(t => t.type === 'Expense');
        }

        // 2. Sort
        filteredTrans.sort((a, b) => {
            if (sortVal === 'date-desc') return new Date(b.date) - new Date(a.date);
            if (sortVal === 'date-asc') return new Date(a.date) - new Date(b.date);
            if (sortVal === 'amount-desc') return b.amount - a.amount;
            if (sortVal === 'amount-asc') return a.amount - b.amount;
            return 0;
        });

        // 3. Render
        if (filteredTrans.length === 0) {
            tbody.innerHTML = '<tr><td colspan="5" class="px-6 py-10 text-center text-stone-400">데이터가 없습니다.</td></tr>';
            return;
        }

        filteredTrans.forEach(t => {
            const row = document.createElement('tr');
            const colorClass = t.type === 'Income' ? 'text-emerald-600' : 'text-stone-600';
            const sign = t.type === 'Income' ? '+' : '-';
            
            row.innerHTML = `
                <td class="px-6 py-4 whitespace-nowrap text-stone-500 text-xs">${t.date}</td>
                <td class="px-6 py-4 whitespace-nowrap text-stone-900 font-medium">${t.description}</td>
                <td class="px-6 py-4 whitespace-nowrap"><span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-stone-50 text-stone-600">${t.category}</span></td>
                <td class="px-6 py-4 whitespace-nowrap text-xs text-stone-400">${t.costType === 'n/a' ? '-' : (t.costType === 'Fixed' ? '고정' : '변동')}</td>
                <td class="px-6 py-4 whitespace-nowrap text-right font-medium ${colorClass}">${sign}${formatCurrency(t.amount)}</td>
            `;
            tbody.appendChild(row);
        });
    }

    window.openTransactionModal = () => {
        const modal = document.getElementById('transactionModal');
        if(!modal) return;

        modal.classList.remove('hidden');
        document.getElementById('trans-modal-title').textContent = `상세 거래 보고서 (${state.selectedMonth})`;
        
        // Reset to defaults when opening
        state.currentTransFilter = 'All';
        const sortSelect = document.getElementById('trans-sort-select');
        if(sortSelect) sortSelect.value = 'date-desc';
        
        // Reset Button UI explicitly
        document.querySelectorAll('[id^="btn-trans-"]').forEach(btn => {
            btn.classList.remove('bg-teal-50', 'text-teal-700');
            btn.classList.add('bg-white', 'text-stone-600');
        });
        const btnAll = document.getElementById('btn-trans-all');
        if(btnAll) btnAll.classList.add('bg-teal-50', 'text-teal-700');

        renderTransactionModalTable();
    };
    
    window.closeTransactionModal = () => {
        const modal = document.getElementById('transactionModal');
        if(modal) modal.classList.add('hidden');
    };
        
        // --- 6. CORE LOGIC & RENDERING ---
        function updateDashboard() {
            // Update labels
            document.querySelectorAll('#asset-month-label, #pnl-month-label').forEach(el => el.textContent = `(${state.selectedMonth})`);

            if (state.currentTab === 'assets') {
                renderAssets();
            } else if (state.currentTab === 'pnl') {
                renderPnL();
            } else if (state.currentTab === 'cashflow') {
                renderCashFlow();
            }
        }

        function renderAssets() {
            // Helper: Filter Logic
            // '연금'이 포함된 AssetType을 가진 항목은 includePension이 false일 때 제외
            const filterData = (item) => {
                if (state.includePension) return true; // 다 보여줌
                if (item.subType && item.subType.includes('연금')) return false; // 연금 제외
                return true;
            };

            // 1. Calculate Snapshot for Selected Month
            const currentBalances = monthlyBalances.filter(b => b.month === state.selectedMonth && filterData(b));
            
            const totalAssets = currentBalances.filter(b => b.type === 'Asset').reduce((sum, b) => sum + b.amount, 0);
            const totalLiabilities = currentBalances.filter(b => b.type === 'Liability').reduce((sum, b) => sum + b.amount, 0);
            const netWorth = totalAssets - totalLiabilities;

            // Update KPIs
            kpiElements.netWorth.textContent = formatCurrency(netWorth);
            kpiElements.assets.textContent = formatCurrency(totalAssets);
            kpiElements.liabilities.textContent = formatCurrency(totalLiabilities);

            // 2. Trend Data (All Months)
            const trendDataFull = months.map(m => {
                const monthRecs = monthlyBalances.filter(b => b.month === m && filterData(b));
                const assets = monthRecs.filter(b => b.type === 'Asset').reduce((s, b) => s + b.amount, 0);
                const liabs = monthRecs.filter(b => b.type === 'Liability').reduce((s, b) => s + b.amount, 0);
                return { month: m, assets, liabs, netWorth: assets - liabs };
            });

            // FILTER: Slider controls Start Date (Anchor Right)
            // Slider value = Start Index
            // Max Value (Right): Show only last 12 months
            // Min Value (Left): Show All Time (Start from 0)
            
            const startIndex = Math.min(state.sliderStart, trendDataFull.length - 1); 
            // 만약 sliderStart가 너무 크면 조정.
            // 로직 수정: 슬라이더 값이 "보여줄 윈도우의 시작점"을 의미하도록 설정
            // 하지만 보통 슬라이더는 "과거 -> 현재"로 이동하므로,
            // 슬라이더 값이 커질수록 "최신 데이터"를 보여주는 것이 직관적임.
            // 여기서는 단순하게: 슬라이더 값 = 시작 인덱스
            
            let sliceStart = state.sliderStart;
            // 안전장치: 데이터 길이보다 크면 안됨
            if (sliceStart > trendDataFull.length - 2) sliceStart = Math.max(0, trendDataFull.length - 12);
            
            // 항상 최소 2개 포인트는 보여주기
            let sliceEnd = Math.min(trendDataFull.length, sliceStart + 24); // 최대 24개월치 보여주기

            // 사용자가 보고 싶은 구간을 슬라이더로 조정?
            // 현재 UX: 슬라이더가 윈도우의 시작점을 결정.
            // 개선: 슬라이더 값 그대로 사용.
            let chartData = trendDataFull.slice(sliceStart, trendDataFull.length); 
            
            // 만약 데이터가 너무 많으면 앞부분 자르기 (최대 36개월 등으로 제한 가능)
            // 여기서는 슬라이더가 'Start Index' 역할을 하므로, 끝까지 보여줌.


            // CHART: Total Asset Trend (Equity (Orange) + Liabilities (Gray))
            // CHART: Total Asset Trend (Equity (Orange) + Liabilities (Gray))
            renderChart('netWorthChart', 'line', {
                labels: chartData.map(d => d.month),
                datasets: [
                    {
                        label: '순자산 (Net Worth)',
                        data: chartData.map(d => d.netWorth),
                        borderColor: '#f97316', // Orange 500
                        backgroundColor: 'rgba(249, 115, 22, 0.6)', 
                        fill: "origin",
                        tension: 0.4,
                        pointBackgroundColor: '#f97316',
                        pointBorderColor: '#fff',
                        pointRadius: 4
                    },
                    {
                        label: '부채 (Liabilities)',
                        data: chartData.map(d => d.liabs),
                        borderColor: '#94a3b8', // Slate 400
                        backgroundColor: 'rgba(148, 163, 184, 0.4)', // Slate 400 transparent
                        fill: "-1", // Stack on top
                        tension: 0.4,
                        pointBackgroundColor: '#94a3b8',
                        pointBorderColor: '#fff', // 흰색 테두리 추가
                        pointRadius: 4, // 마커 표시
                        pointHoverRadius: 6,
                        order: 1
                    }
                ]
            }, {
                interaction: {
                    mode: 'index', // Better for stacked
                    intersect: false
                },
                scales: {
                    y: { 
                        beginAtZero: true, // 0부터 시작하도록 고정
                        stacked: true,
                        grid: { color: '#f5f5f4' }, 
                        ticks: { 
                            font: { size: 10 },
                            callback: function(value) {
                                return (value / 100000000).toFixed(1) + '억';
                            }
                        } 
                    },
                    x: {
                        grid: { display: false }
                    }
                },
                plugins: {
                     tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) {
                                    label += ': ';
                                }
                                if (context.parsed.y !== null) {
                                    label += (context.parsed.y / 100000000).toFixed(2) + '억';
                                }
                                return label;
                            }
                        }
                    }
                }
            });

            // CHART: Portfolio Allocation (Pie)
            const assetsByCat = {};
            currentBalances.filter(b => b.type === 'Asset').forEach(b => {
                assetsByCat[b.category] = (assetsByCat[b.category] || 0) + b.amount;
            });

            renderChart('portfolioChart', 'doughnut', {
                labels: Object.keys(assetsByCat),
                datasets: [{
                    data: Object.values(assetsByCat),
                    backgroundColor: ['#14b8a6', '#0ea5e9', '#6366f1', '#a855f7', '#ec4899', '#f43f5e']
                }]
            }, {
                onClick: (e, elements, chart) => {
                    if (elements.length > 0) {
                        // 1. Slice Clicked: Open Detail for that Category
                        const index = elements[0].index;
                        const categoryName = chart.data.labels[index];
                        openBreakdownModal('Category:' + categoryName);
                    } else {
                        // 2. Background Clicked: Open General Overview
                        openBreakdownModal('Asset');
                    }
                },
                plugins: {
                    legend: { position: 'right' },
                    datalabels: { // DataLabels Styling
                        color: '#ffffff',
                        font: { 
                            family: "'Inter', sans-serif",
                            weight: '600', 
                            size: 13 
                        },
                        textStrokeColor: 'rgba(0,0,0,0.2)', // Text Outline for visibility
                        textStrokeWidth: 3,
                        textShadowBlur: 4,
                        textShadowColor: 'rgba(0, 0, 0, 0.3)',
                        formatter: (value, ctx) => {
                            let sum = 0;
                            let dataArr = ctx.chart.data.datasets[0].data;
                            dataArr.map(data => { sum += data; });
                            let percentage = (value*100 / sum).toFixed(1)+"%";
                            return percentage; 
                        },
                        display: (context) => {
                            let value = context.dataset.data[context.dataIndex];
                            let sum = context.dataset.data.reduce((a, b) => a + b, 0);
                            return (value / sum) > 0.05; // > 5% only
                        },
                        anchor: 'center',
                        align: 'center',
                        offset: 0
                    }
                }
            }, [ChartDataLabels]); // Activate Plugin ONLY for this chart
            
            renderROI(); 
            renderProfitChart(); 
        }

        // CHART: Profit Amount (Stacked Bar)
        function renderProfitChart() {
             // Reuse Logic: Identify Investment Assets
            const investmentAssets = new Set();
            // Exclude Safe Assets AND Real Estate
            const excludedCategories = ['예금', '보증금', '현금', '부동산'];
            const isPension = (item) => item.subType && item.subType.includes('연금');

            monthlyBalances.forEach(b => {
                if (b.type === 'Asset' && b.cost > 0) {
                    if (excludedCategories.includes(b.category)) return;
                     if (!state.includePension && isPension(b)) return;
                     investmentAssets.add(b.name);
                }
            });

            // Prepare Datasets (Sorted for consistency)
            const sortedAssets = Array.from(investmentAssets).sort();

            const datasets = sortedAssets.map((assetName) => {
                const color = getAssetColor(assetName); 

                // Data Points
                const fullDataPoints = months.map(m => {
                    const record = monthlyBalances.find(b => b.month === m && b.name === assetName);
                    
                    if (record && record.cost > 0) {
                        return record.amount - record.cost;
                    }
                    return 0;
                });
                
                // Slice Data based on Slider
                const roiSlider = document.getElementById('roiScrollSlider');
                let sliceStart = 0;
                let sliceEnd = months.length;
                if (roiSlider) {
                    const endIdx = parseInt(roiSlider.value) + 1;
                    sliceStart = Math.max(0, endIdx - 12);
                    sliceEnd = Math.max(0, endIdx + 1);
                }
                const slicedDataPoints = fullDataPoints.slice(sliceStart, sliceEnd);

                return {
                    label: assetName.length > 8 ? assetName.substring(0,8)+'..' : assetName, 
                    fullLabel: assetName, 
                    data: slicedDataPoints,
                    backgroundColor: color,
                    borderColor: color, // Border needed for clarity? Maybe not for stacked bar.
                    borderWidth: 0,
                    barPercentage: 0.6,
                };
            });

             // Prepare Labels (Always prepare labels even if no data)
            const roiSlider = document.getElementById('roiScrollSlider');
            let sliceStart = 0;
            let sliceEnd = months.length;
            if (roiSlider) {
                const endIdx = parseInt(roiSlider.value) + 1;
                sliceStart = Math.max(0, endIdx - 12);
                sliceEnd = Math.max(0, endIdx + 1);
            }
            const slicedLabels = months.slice(sliceStart, sliceEnd);

            // 1. GAP Effect (Thick White Line)
            const gapData = Array(slicedLabels.length).fill(0);
            const gapDataset = {
                type: 'line',
                label: '', 
                data: gapData,
                borderColor: '#ffffff', // White gap
                borderWidth: 6, // Thickness of gap
                pointRadius: 0,
                fill: false,
                order: 1 // Above bars
            };

            // 2. Dashed Zero Line (Overlay)
            const dashDataset = {
                type: 'line',
                label: '', 
                data: gapData, // Same 0 data
                borderColor: '#94a3b8',
                borderWidth: 2,
                borderDash: [6, 4],
                pointRadius: 0,
                fill: false,
                order: 0 // Topmost
            };

            // Render Chart (Always Render)
            renderChart('profitChart', 'bar', {
                labels: slicedLabels,
                datasets: [dashDataset, gapDataset, ...datasets] // Order matters 
            }, {
                plugins: {
                    legend: { display: false }, 
                    datalabels: { 
                        display: function(context) {
                            if (!context.dataset.data[context.dataIndex]) return false;
                            const val = Math.abs(context.dataset.data[context.dataIndex]);
                            return val > 100000; 
                        },
                        formatter: function(value, context) {
                            return context.dataset.label; 
                        },
                        color: 'white',
                        font: { weight: 'bold', size: 10 },
                        anchor: 'center',
                        align: 'center',
                        clip: true
                    },
                    tooltip: {
                         callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) label += ': ';
                                if (context.parsed.y !== null) label += formatCurrency(context.parsed.y);
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: { stacked: true, grid: { display: false } },
                    y: { 
                        stacked: true,
                        grid: { display: false }, 
                        ticks: {
                            callback: function(value) { return (value/1000000).toFixed(0) + 'M'; } 
                        },
                        suggestedMin: -1000000, // Force scale to show even if empty
                        suggestedMax: 1000000
                    }
                }
            }, [ChartDataLabels]); // Removed zeroLinePlugin
        }

        // CHART: Investment Performance (ROI) - Monthly Trend
        function renderROI() {
            // Identify Investment Assets
            const investmentAssets = new Set();
             // Exclude Safe Assets (Pension controlled by toggle)
            const excludedCategories = ['예금', '보증금', '현금'];
            const isPension = (item) => item.subType && item.subType.includes('연금');

            monthlyBalances.forEach(b => {
                if (b.type === 'Asset' && b.cost > 0) {
                     if (excludedCategories.includes(b.category)) return;
                     if (!state.includePension && isPension(b)) return;
                     investmentAssets.add(b.name);
                }
            });

            if (investmentAssets.size === 0) return;

            // Prepare Datasets (Sorted for consistency)
            const sortedAssets = Array.from(investmentAssets).sort();

            const datasets = sortedAssets.map((assetName) => {
                const color = getAssetColor(assetName); 

                // Data Points
                const fullDataPoints = months.map(m => {
                    const record = monthlyBalances.find(b => b.month === m && b.name === assetName);
                    
                    if (record && record.cost > 0) {
                        return ((record.amount - record.cost) / record.cost) * 100;
                    }
                    return null;
                });
                
                // Slice Data based on Slider
                const roiSlider = document.getElementById('roiScrollSlider');
                let sliceStart = 0;
                let sliceEnd = months.length;
                if (roiSlider) {
                    const endIdx = parseInt(roiSlider.value) + 1;
                    sliceStart = Math.max(0, endIdx - 12);
                    sliceEnd = Math.max(0, endIdx + 1);
                }
                const slicedDataPoints = fullDataPoints.slice(sliceStart, sliceEnd);

                return {
                    label: assetName.length > 8 ? assetName.substring(0,8)+'..' : assetName, 
                    fullLabel: assetName, 
                    data: slicedDataPoints,
                    borderColor: color,
                    backgroundColor: color,
                    borderWidth: 3, // Thicker lines
                    tension: 0.3, 
                    pointRadius: 4, // Bigger points
                    pointHoverRadius: 6,
                    spanGaps: true
                };
            });

             // Prepare Labels
            const roiSlider = document.getElementById('roiScrollSlider');
            let sliceStart = 0;
            let sliceEnd = months.length;
            if (roiSlider) {
                const endIdx = parseInt(roiSlider.value) + 1;
                sliceStart = Math.max(0, endIdx - 12);
                sliceEnd = Math.max(0, endIdx + 1);
            }
            const slicedLabels = months.slice(sliceStart, sliceEnd);


            // Zero Line (Dashed)
            const zeroData = Array(slicedLabels.length).fill(0);
            const zeroDataset = {
                label: '', 
                data: zeroData,
                borderColor: '#94a3b8',
                borderWidth: 2,
                borderDash: [6, 4], 
                pointRadius: 0, 
                pointHoverRadius: 0,
                fill: false,
                tension: 0,
                order: 100 
            };

            // 3. Render Chart
            renderChart('roiChart', 'line', {
                labels: slicedLabels,
                datasets: [zeroDataset, ...datasets], // Add Zero Line first
            }, {
                layout: {
                    padding: { right: 30 } 
                },
                interaction: {
                    mode: 'nearest', 
                    intersect: true, // 1. Only single item tooltip
                    axis: 'xy'
                },
                scales: {
                    y: {
                        beginAtZero: false, 
                        grid: { 
                            color: '#f5f5f4', 
                        },
                        ticks: {
                            callback: function(value) {
                                return value.toFixed(0) + '%';
                            }
                        }
                    },
                    x: {
                        grid: { display: false }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: { 
                            boxWidth: 10, 
                            font: { size: 10 }, 
                            usePointStyle: true,
                            filter: item => item.text !== '', // Hide Zero Line
                            generateLabels: (chart) => {
                                // Default labels
                                const labels = Chart.defaults.plugins.legend.labels.generateLabels(chart);
                                labels.forEach(label => {
                                    const dataset = chart.data.datasets[label.datasetIndex];
                                    // Get last valid value
                                    let lastValue = 0;
                                    for(let i=dataset.data.length-1; i>=0; i--) {
                                        if(dataset.data[i] !== null) {
                                            lastValue = dataset.data[i];
                                            break;
                                        }
                                    }
                                    // If negative, Red Text
                                    if (lastValue < 0) {
                                        label.fontColor = '#ef4444';
                                        label.fillStyle = '#ef4444'; 
                                    }
                                });
                                return labels;
                            }
                        }
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const dataset = context.dataset;
                                const fullName = dataset.fullLabel || dataset.label;
                                const value = context.parsed.y;
                                return `${fullName}: ${value.toFixed(2)}%`;
                            }
                        }
                    },
                    datalabels: { 
                        display: function(context) {
                             // Show label ONLY for the last data point
                            return context.dataIndex === context.dataset.data.length - 1; 
                        },
                        align: 'right',
                        anchor: 'end',
                        color: function(context) {
                            const value = context.dataset.data[context.dataIndex];
                            // If value is negative, use RED color. Else usage line color.
                            return value < 0 ? '#ef4444' : context.dataset.borderColor;
                        },
                        font: {
                            weight: 'bold',
                            size: 11
                        },
                        formatter: function(value) {
                            return Math.round(value) + '%';
                        }
                    } 
                }
            }, [ChartDataLabels]); // Activate Plugin for labels

            // Update Title Custom Tooltip (With Profit Amount)
            const latestIndex = slicedLabels.length - 1;
            if (latestIndex >= 0) {
                const currentMonth = slicedLabels[latestIndex];
                
                const summaryLinesHtml = datasets
                    .filter(d => d.label && d.label !== '') 
                    .filter(d => d.data[latestIndex] !== null) 
                    .sort((a,b) => b.data[latestIndex] - a.data[latestIndex])
                    .map(d => {
                        const val = d.data[latestIndex];
                        const colorClass = val >= 0 ? 'text-teal-300' : 'text-rose-300';
                        
                        // Find Raw Data for Amount Calculation
                        const record = monthlyBalances.find(b => b.month === currentMonth && b.name === d.fullLabel);
                        let amountStr = '';
                        if(record) {
                            const profit = record.amount - record.cost;
                            const sign = profit >= 0 ? '+' : '';
                            amountStr = `${sign}${formatCurrency(profit)}`;
                        }

                        return `
                        <div class="flex justify-between items-center py-0.5">
                            <span class="truncate pr-2" style="max-width: 120px;">${d.fullLabel}</span>
                            <div class="text-right">
                                <span class="${colorClass} mr-1 font-medium">${amountStr}</span>
                                <span class="text-stone-400 text-[10px]">(${val.toFixed(1)}%)</span>
                            </div>
                        </div>`
                    })
                    .join('');
                
                const titleElem = document.getElementById('roi-chart-title');
                const tooltipElem = document.getElementById('roi-custom-tooltip');
                
                if(titleElem && tooltipElem) {
                    // Widen tooltip
                    tooltipElem.classList.remove('w-64');
                    tooltipElem.classList.add('w-80');

                    // Update content
                    tooltipElem.innerHTML = `<div class="font-bold mb-1 border-b border-stone-600 pb-1">현재 수익률 (${slicedLabels[latestIndex]})</div>` + summaryLinesHtml;

                    // Hover Events
                    titleElem.onmouseenter = () => tooltipElem.classList.remove('hidden');
                    titleElem.onmouseleave = () => tooltipElem.classList.add('hidden');
                }
            }
        }


        function renderPnL() {
            // Filter transactions for selected month
            const currentTrans = transactions.filter(t => t.date.startsWith(state.selectedMonth));

            // Breakdown Expenses
            const expenses = currentTrans.filter(t => t.type === 'Expense');
            
            // By Type (Fixed/Var)
            let fixedTotal = 0, varTotal = 0;
            expenses.forEach(t => {
                if (t.costType === 'Fixed') fixedTotal += t.amount;
                else varTotal += t.amount;
            });

            // CHART: Expense Structure (Stacked Bar - using global context for simplicity, but showing comparison across months is better. 
            // Let's do a 6-month lookback for the bar chart to show trend)
            
            // Get last 6 months including current
            const lookbackMonths = months.slice(Math.max(0, months.indexOf(state.selectedMonth) - 5), months.indexOf(state.selectedMonth) + 1);
            
            const stackedData = lookbackMonths.map(m => {
                const mTrans = transactions.filter(t => t.date.startsWith(m));
                
                // Income
                const income = mTrans.filter(t => t.type === 'Income').reduce((sum, t) => sum + t.amount, 0);

                // Expense Breakdown
                const expenseTrans = mTrans.filter(t => t.type === 'Expense');
                const fixed = expenseTrans.filter(t => t.costType === 'Fixed').reduce((sum, t) => sum + t.amount, 0);
                const variable = expenseTrans.filter(t => t.costType === 'Variable').reduce((sum, t) => sum + t.amount, 0);
                const netIncome = income - fixed - variable;
                
                return { month: m, fixed, variable, income, netIncome };
            });

            renderChart('expenseStructureChart', 'bar', {
                labels: stackedData.map(d => d.month),
                datasets: [
                    { 
                        type: 'line',
                        label: '총 수입', 
                        data: stackedData.map(d => d.income), 
                        borderColor: '#10b981', // Emerald 500
                        backgroundColor: '#10b981',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        fill: false,
                        order: 0, // Draw on top
                        stack: 'income' // Separate stack
                    },
                    { 
                        type: 'line',
                        label: '순수입', 
                        data: stackedData.map(d => d.netIncome), 
                        borderColor: '#3b82f6', // Blue 500
                        backgroundColor: '#3b82f6',
                        borderWidth: 2,
                        tension: 0.3,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        fill: false,
                        order: 1,
                        stack: 'net' // Separate stack
                    },
                    { label: '고정비', data: stackedData.map(d => d.fixed), backgroundColor: '#6366f1', order: 2, stack: 'expense' }, // Indigo
                    { label: '변동비', data: stackedData.map(d => d.variable), backgroundColor: '#ec4899', order: 3, stack: 'expense' } // Pink
                ]
            }, {
                scales: {
                    x: { stacked: true },
                    y: { stacked: true }
                },
                onClick: (e, elements, chart) => {
                    if (elements.length > 0) {
                        const datasetIndex = elements[0].datasetIndex;
                        const label = chart.data.datasets[datasetIndex].label; 
                        
                        let type = '';
                        if (label === '총 수입') type = 'Income';
                        else if (label === '고정비') type = 'Fixed';
                        else if (label === '변동비') type = 'Variable';
                        
                        if (type) openBreakdownModal(type);
                    }
                }
            });

            // CHART: Category Breakdown
            // CHART: Category Breakdown
            const expenseByCat = {};
            const typeByCat = {};

            expenses.forEach(t => {
                expenseByCat[t.category] = (expenseByCat[t.category] || 0) + t.amount;
                // Identify type (Fixed/Variable) - assume consistency per category
                if (!typeByCat[t.category]) {
                     typeByCat[t.category] = t.costType === 'Fixed' ? '고정' : '변동';
                }
            });
            
            // Sort top 6 for Doughnut
            const sortedCats = Object.entries(expenseByCat).sort((a,b) => b[1] - a[1]).slice(0, 6);

            // Pattern Generator for Variable Costs
            const createPattern = (color) => {
                const canvas = document.createElement('canvas');
                canvas.width = 12;
                canvas.height = 12;
                const ctx = canvas.getContext('2d');
                
                // Solid Background
                ctx.fillStyle = color;
                ctx.fillRect(0,0,12,12);
                
                // Stripe Pattern (White transparent)
                ctx.strokeStyle = 'rgba(255,255,255,0.35)'; // Visible but subtle
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(0, 12);
                ctx.lineTo(12, 0);
                // Extra lines for seamless tiling
                 ctx.moveTo(-2, 2);
                ctx.lineTo(2, -2);
                 ctx.moveTo(10, 14);
                ctx.lineTo(14, 10);
                ctx.stroke();
                
                return ctx.createPattern(canvas, 'repeat');
            };

            const baseColors = ['#f59e0b', '#ec4899', '#8b5cf6', '#10b981', '#3b82f6', '#f43f5e'];
            const bgColors = sortedCats.map((item, i) => {
                const catName = item[0];
                const type = typeByCat[catName]; // '고정' or '변동'
                const baseColor = baseColors[i % baseColors.length];
                
                if (type === '변동') {
                    // Create Pattern for Variable
                    return createPattern(baseColor);
                }
                return baseColor; // Solid for Fixed
            });

            renderChart('categoryBreakdownChart', 'doughnut', {
                labels: sortedCats.map(i => `${i[0]} (${typeByCat[i[0]]})`),
                datasets: [{
                    data: sortedCats.map(i => i[1]),
                    backgroundColor: bgColors,
                    hoverOffset: 4
                }],
            }, {
                plugins: {
                    legend: { position: 'right', labels: { boxWidth: 10, font: { size: 11 } } },
                    datalabels: { 
                         color: '#ffffff',
                         font: { 
                             family: "'Inter', sans-serif",
                             weight: '600', 
                             size: 13 
                         },
                         textStrokeColor: 'rgba(0,0,0,0.2)',
                         textStrokeWidth: 3,
                         textShadowBlur: 4,
                         textShadowColor: 'rgba(0, 0, 0, 0.3)',
                         formatter: (value, ctx) => {
                            let sum = 0;
                            let dataArr = ctx.chart.data.datasets[0].data;
                            dataArr.map(data => { sum += data; });
                            return (value*100 / sum).toFixed(1)+"%";
                        },
                        display: (context) => {
                             let value = context.dataset.data[context.dataIndex];
                             let sum = context.dataset.data.reduce((a, b) => a + b, 0);
                             return (value / sum) > 0.05; // Show if > 5%
                        }
                    } 
                } 
            }, [ChartDataLabels]);

            // TABLE: Recent Transactions
            tableBody.innerHTML = '';
            
            // Filter: Expenses only -> Sort by Amount DESC -> Top 5
            const expensesOnly = currentTrans.filter(t => t.type === 'Expense');
            const sortedTrans = [...expensesOnly].sort((a, b) => b.amount - a.amount).slice(0, 5);
            
            sortedTrans.forEach(t => {
                const row = document.createElement('tr');
                const colorClass = t.type === 'Income' ? 'text-emerald-600' : 'text-stone-600';
                const sign = t.type === 'Income' ? '+' : '-';
                
                row.innerHTML = `
                    <td class="px-6 py-4 whitespace-nowrap text-stone-500">${t.date}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-stone-900 font-medium">${t.description}</td>
                    <td class="px-6 py-4 whitespace-nowrap"><span class="px-2 inline-flex text-xs leading-5 font-semibold rounded-full bg-stone-100 text-stone-800">${t.category}</span></td>
                    <td class="px-6 py-4 whitespace-nowrap text-sm text-stone-500">${t.costType === 'n/a' ? '-' : t.costType}</td>
                    <td class="px-6 py-4 whitespace-nowrap text-right font-medium ${colorClass}">${sign}${formatCurrency(t.amount)}</td>
                `;
                tableBody.appendChild(row);
            });
        }

        function renderCashFlow() {
            // 1. Generate 12 months from selectedMonth (Projection)
            const startMonth = state.selectedMonth; 
            const projectionMonths = [];
            let [currYear, currMonth] = startMonth.split('-').map(Number);
            
            for (let i = 0; i < 12; i++) {
                const mStr = `${currYear}-${String(currMonth).padStart(2, '0')}`;
                projectionMonths.push(mStr);
                currMonth++;
                if (currMonth > 12) {
                    currMonth = 1;
                    currYear++;
                }
            }

            // 2. Calculate 3-month average for baseline from historical Transactions
            const currentIdx = months.indexOf(state.selectedMonth);
            // We use up to 3 months ending at current selected month as baseline
            const historyMonths = months.slice(Math.max(0, currentIdx - 2), currentIdx + 1);
            
            let totalHistIncome = 0;
            let totalHistExpense = 0;
            
            historyMonths.forEach(m => {
                const mTrans = transactions.filter(t => t.date.startsWith(m));
                // Rule 5: Exclude PS, PI in Income (Item field)
                const incomeRows = mTrans.filter(t => t.type === 'Income' && 
                    !(t.description && (t.description.includes('PS') || t.description.includes('PI'))));
                
                totalHistIncome += incomeRows.reduce((s, t) => s + t.amount, 0);
                totalHistExpense += mTrans.filter(t => t.type === 'Expense').reduce((s, t) => s + t.amount, 0);
            });
            
            const avgIncome = historyMonths.length > 0 ? totalHistIncome / historyMonths.length : 0;
            const avgExpense = historyMonths.length > 0 ? totalHistExpense / historyMonths.length : 0;

            // 3. Project for the 12 months
            const projectedData = projectionMonths.map(m => {
                // Baseline (Avg of last 3 months)
                let income = avgIncome;
                let expense = avgExpense;
                
                // Rule 3: Add explicit plans from DB_Cashflow
                const plans = cashflowPlans.filter(p => p.month === m);
                if (plans.length > 0) {
                    console.log(`[Cashflow] ${m}에 계획된 항목 발견:`, plans);
                }
                plans.forEach(p => {
                    if (p.type === 'Income') income += p.amount;
                    else expense += p.amount;
                });
                
                return { 
                    month: m, 
                    income: income, 
                    expense: -expense, // Rule 2: Expense should be below 0
                    net: income - expense 
                };
            });

            // 4. Render Chart
            renderChart('cashFlowChart', 'bar', {
                labels: projectedData.map(d => d.month),
                datasets: [
                    {
                        type: 'line',
                        label: '순유입',
                        data: projectedData.map(d => d.net),
                        borderColor: '#1e293b',
                        borderWidth: 2,
                        tension: 0.3,
                        pointBackgroundColor: '#fff',
                        pointBorderColor: '#1e293b',
                        order: 0,
                        // Data labels for the line
                        datalabels: {
                            align: 'top',
                            anchor: 'end',
                            offset: 4,
                            color: '#1e293b',
                            font: { size: 10, weight: 'bold' },
                            formatter: (val) => (val >= 0 ? '+' : '') + Math.round(val/10000).toLocaleString() + '만'
                        }
                    },
                    {
                        type: 'bar',
                        label: '수입 (+)',
                        data: projectedData.map(d => d.income),
                        backgroundColor: '#34d399', // Emerald 400
                        borderRadius: 4,
                        order: 1,
                        datalabels: { display: false }
                    },
                    {
                        type: 'bar',
                        label: '지출 (-)',
                        data: projectedData.map(d => d.expense),
                        backgroundColor: '#fb7185', // Rose 400
                        borderRadius: 4,
                        order: 2,
                        datalabels: { display: false }
                    }
                ]
            }, {
                scales: {
                    x: { grid: { display: false } },
                    y: { 
                        grid: { color: '#f5f5f4' },
                        ticks: {
                            callback: (val) => val.toLocaleString() + '원'
                        }
                    }
                },
                onClick: (e, elements, chart) => {
                    if (elements.length > 0) {
                        const idx = elements[0].index;
                        const dsIdx = elements[0].datasetIndex;
                        const targetMonth = projectedData[idx].month;
                        const label = chart.data.datasets[dsIdx].label;
                        
                        let type = '';
                        if (label.includes('수입')) type = 'Income_Proj';
                        else if (label.includes('지출')) type = 'Expense_Proj';
                        
                        if (type) showProjectedCashFlowDetails(targetMonth, type);
                    }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) label += ': ';
                                label += formatCurrency(Math.abs(context.parsed.y));
                                return label;
                            }
                        }
                    },
                    datalabels: {
                        display: true // Enable globally for the plugins we passed
                    }
                }
            }, [ChartDataLabels]); // Pass the plugin
        }

        // --- 6.2 PROJECTED CASHFLOW DRILL-DOWN ---
        function showProjectedCashFlowDetails(targetM, type) {
            const isIncome = type === 'Income_Proj';
            const displayTitle = isIncome ? '수입 상세 예측' : '지출 상세 예측';
            
            document.getElementById('modal-title').textContent = `${displayTitle} (${targetM})`;
            sections.modal.classList.remove('hidden');
            
            // 1. Calculate Baseline Profile (Avg per Category over last 3 months)
            const currentIdx = months.indexOf(state.selectedMonth);
            const historyMonths = months.slice(Math.max(0, currentIdx - 2), currentIdx + 1);
            const n = historyMonths.length || 1;
            
            const breakdown = {};
            
            // Baseline from history
            historyMonths.forEach(m => {
                const mTrans = transactions.filter(t => t.date.startsWith(m));
                const targetTrans = isIncome 
                    ? mTrans.filter(t => t.type === 'Income' && !(t.description && (t.description.includes('PS') || t.description.includes('PI'))))
                    : mTrans.filter(t => t.type === 'Expense');
                
                targetTrans.forEach(t => {
                    const key = t.category || '기타';
                    breakdown[key] = (breakdown[key] || 0) + (t.amount / n);
                });
            });

            // 2. Add Planned Items from DB_Cashflow
            const plans = cashflowPlans.filter(p => p.month === targetM && p.type === (isIncome ? 'Income' : 'Expense'));
            plans.forEach(p => {
                const key = `[계획] ${p.item}`;
                breakdown[key] = (breakdown[key] || 0) + p.amount;
            });

            // 3. Render using existing modal logic
            const detailCurrentDiv = document.getElementById('modalDetailsCurrent');
            const detailCompareDiv = document.getElementById('modalDetailsCompare');
            const compareSection = document.getElementById('comparison-section');
            
            // Hide comparison for projection for now to keep it clean
            if(compareSection) compareSection.classList.add('hidden'); 

            const dataLabelConfig = {
                color: '#ffffff',
                font: { family: "'Inter', sans-serif", weight: '600', size: 12 },
                formatter: (value, ctx) => {
                    let sum = ctx.dataset.data.reduce((a, b) => a + b, 0);
                    return (value*100 / sum).toFixed(1)+"%";
                },
                display: (ctx) => {
                    const sum = ctx.dataset.data.reduce((a,b)=>a+b,0);
                    return sum > 0 ? (ctx.dataset.data[ctx.dataIndex] / sum) > 0.05 : false;
                }
            };

            renderChart('modalChartCurrent', 'doughnut', {
                labels: Object.keys(breakdown),
                datasets: [{
                    data: Object.values(breakdown),
                    backgroundColor: globalPalette
                }]
            }, {
                plugins: {
                    legend: { position: 'bottom', labels: { boxWidth: 10, font: { size: 10 } } },
                    datalabels: dataLabelConfig
                }
            }, [ChartDataLabels]);

            const total = Object.values(breakdown).reduce((a, b) => a + b, 0);
            detailCurrentDiv.innerHTML = Object.entries(breakdown)
                .sort((a,b) => b[1] - a[1])
                .map(([k, v]) => {
                    if (v === 0) return '';
                    const pct = total > 0 ? ((v / total) * 100).toFixed(1) + '%' : '0%';
                    const isPlanned = k.startsWith('[계획]');
                    const labelClass = isPlanned ? 'text-teal-600 font-bold' : 'text-stone-700';
                    return `
                    <div class="flex justify-between items-center border-b border-stone-50 py-3">
                        <span class="truncate pr-2 ${labelClass}">${k}</span>
                        <div class="whitespace-nowrap">
                            <span class="font-medium text-stone-900">${formatCurrency(Math.round(v))}</span>
                            <span class="text-xs text-stone-400 ml-1">(${pct})</span>
                        </div>
                    </div>`;
                }).join('');
        }

        // --- 7. HELPER: RENDER CHART ---
        // --- 7. HELPER: RENDER CHART ---
        function renderChart(canvasId, type, data, extraOptions = {}, plugins = []) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) {
                console.warn(`[renderChart] Canvas element not found: ${canvasId}`);
                return;
            }
            const ctx = canvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (state.charts[canvasId]) {
                state.charts[canvasId].destroy();
            }

            // Defaults
            const defaults = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'bottom', labels: { usePointStyle: true, padding: 20, font: { family: 'Inter', size: 11 } } },
                    tooltip: { 
                        backgroundColor: 'rgba(255, 255, 255, 0.95)', 
                        titleColor: '#1c1917', 
                        bodyColor: '#44403c', 
                        borderColor: '#e7e5e4', 
                        borderWidth: 1,
                        padding: 12,
                        cornerRadius: 8,
                        displayColors: true,
                        boxPadding: 4
                    }
                },
                scales: type !== 'doughnut' ? {
                    y: { grid: { color: '#f5f5f4' }, ticks: { font: { size: 10 } } },
                    x: { grid: { display: false }, ticks: { font: { size: 10 } } }
                } : {}
            };

            // Merge options
            const options = { ...defaults, ...extraOptions };
            if (extraOptions.scales) options.scales = { ...defaults.scales, ...extraOptions.scales }; // Deep merge scales if provided

            state.charts[canvasId] = new Chart(ctx, { type, data, options, plugins });
        }

        // Start
        init();

    </script>
</body>
</html>